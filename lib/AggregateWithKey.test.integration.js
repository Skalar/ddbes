import test from 'blue-tape'
import {withCleanup, assertAggregateCommits} from '~/test/utils'
import * as dynamodb from '~/lib/dynamodb'
// import * as s3 from '~/lib/s3'
import AggregateWithKey from '~/lib/AggregateWithKey'

class Order extends AggregateWithKey {
  static keyProperties = [
    'accountId',
    {name: 'orderId', value: ({orderId}) => orderId || 'autogenerated'},
  ]

  static reducer = (state = {}, event) => {
    switch (event.type) {
      case 'Created': {
        const {accountId, orderId} = event
        Object.assign(state, {accountId, orderId})

        return state
      }
      default:
        return state
    }
  }

  create({accountId, orderId}) {
    return this.commit({type: 'Created', accountId, orderId})
  }
}

test('AggregateWithKey.getKeyFromProps()', async t => {
  class TestAggregate extends AggregateWithKey {
    static keyProperties = ['id']
  }

  t.throws(
    () => TestAggregate.getKeyFromProps({}),
    /Missing required key property: id/,
    'throws and error if required key property is omitted'
  )

  TestAggregate.keyProperties = ['id', {name: 'userId', optional: true}]

  t.doesNotThrow(
    () => TestAggregate.getKeyFromProps({id: 'test'}),
    /Missing required key property: userId/,
    'does not throw error when key property marked as optional is omitted'
  )

  t.equal(
    TestAggregate.getKeyFromProps({id: 'test', userId: 'gudleik'}).string,
    'test.gudleik',
    'uses . to separate the key properties by default'
  )

  TestAggregate.keyPropSeparator = '+'

  t.equal(
    TestAggregate.getKeyFromProps({id: 'test', userId: 'gudleik'}).string,
    'test+gudleik',
    'allows keyPropSeparator to be customized'
  )

  TestAggregate.keyPropSeparator = '.'

  TestAggregate.keyProperties = [{name: 'id', value: ({id}) => `_${id}_`}]

  t.equal(
    TestAggregate.getKeyFromProps({id: 'test'}).string,
    '_test_',
    'uses key property value function if defined'
  )
})

test('AggregateWithKey.create()', async t => {
  await withCleanup(async () => {
    const order = await Order.create({accountId: 'myaccount'})

    t.equal(
      order.aggregateId,
      'Order:myaccount.autogenerated',
      'uses the correct aggregateId with autogenerated key property'
    )

    t.equal(order.version, 1, 'reports the correct version')
    t.deepEqual(
      order.state,
      {accountId: 'myaccount', orderId: 'autogenerated'},
      'correctly reduces the state'
    )

    await assertAggregateCommits(
      t,
      'Order:myaccount.autogenerated',
      [
        {
          version: 1,
          events: [
            {type: 'Created', accountId: 'myaccount', orderId: 'autogenerated'},
          ],
        },
      ],
      'commits to the store correctly via create() instance function'
    )

    const order2 = await Order.create({
      accountId: 'myaccount',
      orderId: 'orderId',
    })

    t.equal(
      order2.aggregateId,
      'Order:myaccount.orderId',
      'uses the correct aggregateId with all key properties provided'
    )
  })
})

test('AggregateWithKey.load()', async t => {
  await withCleanup(async () => {
    await dynamodb.batchWriteCommits('Order:myaccount.0000', [
      {
        committedAt: new Date('2017-01-01'),
        events: [
          {
            type: 'Created',
            accountId: 'myaccount',
            orderId: '0000',
          },
        ],
      },
    ])

    const order = await Order.load({accountId: 'myaccount', orderId: '0000'})

    t.equal(
      order.aggregateId,
      'Order:myaccount.0000',
      'loads the correct aggregateId'
    )

    t.equal(order.version, 1, 'loads the latest version')

    t.deepEqual(
      order.state,
      {accountId: 'myaccount', orderId: '0000'},
      'correctly reduces the HEAD state given no arguments'
    )
  })
})

test('AggregateWithKey.getState()', async t => {
  await withCleanup(async () => {
    const accountId = 'myaccount'
    const orderId = '0000'

    await Order.create({accountId, orderId})
    const state = await Order.getState({accountId, orderId})

    t.deepEqual(state, {accountId, orderId}, 'retrieves the correct state')
  })
})

// test('Aggregate.load()', async t => {
//   await withCleanup(async () => {})
// })
